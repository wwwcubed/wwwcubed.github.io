"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9002],{59002:function(t,a,r){r.d(a,{E:function(){return Erc721},a:function(){return Erc721WithQuantitySignatureMintable}});var e=r(61744),i=r(2593),n=r(29251),s=r(9279),c=r(31886),o=r(84243),p=r(31665),l=r(4411),d=r(35618),h=r(34709),u=r(66964),m=r(78079),g=r(52027),y=r(87029),W=r(40721),w=r(99674),f=r(38776),T=r(22185),C=r(1604),b=r(51903);let Erc721Burnable=class Erc721Burnable{featureName=p.cK.name;constructor(t){this.contractWrapper=t}token=(0,u.f)(async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]}))};let Erc721ClaimableWithConditions=class Erc721ClaimableWithConditions{featureName=p.cL.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r;let e=new d.C(this.contractWrapper,p.bg,this.storage);this.conditions=new m.D(this.contractWrapper,e,this.storage)}to=(0,u.f)(async(t,a,r)=>{let e=await this.conditions.getClaimTransaction(t,a,r);return e.setParse(t=>{let r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs),e=r[0].args.startTokenId,i=e.add(a),n=[];for(let a=e;a.lt(i);a=a.add(1))n.push({id:a,receipt:t,data:()=>this.erc721.get(a)});return n}),e})};let Erc721ClaimableZora=class Erc721ClaimableZora{featureName=p.cM.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}to=(0,u.f)(async(t,a,r)=>{let n=await this.contractWrapper.getSigner()?.getAddress();if(t!==n)throw Error("Zora Drop: Destination address must match connected wallet address");if(r?.pricePerToken)throw Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");let s=await this.getSaleDetails(),c=s.publicSalePrice,o=e.parseEther(p.cv.parse("0.000777")),l=i.O$.from(c).add(o).mul(a),d=u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"purchase",args:[a],overrides:{value:l}});return d.setParse(t=>{let r=this.contractWrapper.parseLogs("Sale",t?.logs),e=r[0].args.firstPurchasedTokenId,i=e.add(a),n=[];for(let a=e;a.lt(i);a=a.add(1))n.push({id:a,receipt:t,data:()=>this.erc721.get(a)});return n}),d});async getSaleDetails(){return this.contractWrapper.read("saleDetails",[])}};let Erc721Claimable=class Erc721Claimable{featureName=p.cN.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}async getClaimTransaction(t,a,r){let e={};return r&&r.pricePerToken&&(e=await (0,g.c)(this.contractWrapper,r.pricePerToken,a,r.currencyAddress,r.checkERC20Allowance)),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,a],overrides:e})}to=(0,u.f)(async(t,a,r)=>{let e=await this.getClaimTransaction(t,a,r);return e.setParse(t=>{let r=this.contractWrapper.parseLogs("TokensClaimed",t?.logs),e=r[0].args.startTokenId,i=e.add(a),n=[];for(let a=e;a.lt(i);a=a.add(1))n.push({id:a,receipt:t,data:()=>this.erc721.get(a)});return n}),e})};let Erc721LazyMintable=class Erc721LazyMintable{featureName=p.cO.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r,this.revealer=this.detectErc721Revealable()}lazyMint=(0,u.f)(async(t,a)=>{let r=await this.erc721.nextTokenIdToMint(),e=await (0,h.u)(t,this.storage,r.toNumber(),a),i=(0,h.g)(e);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,i.endsWith("/")?i:`${i}/`,n.Y0("")],parse:t=>{let a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args.startTokenId,e=a[0].args.endTokenId,i=[];for(let a=r;a.lte(e);a=a.add(1))i.push({id:a,receipt:t,data:()=>this.erc721.getTokenMetadata(a)});return i}})});updateMetadata=(0,u.f)(async(t,a,r)=>{let e=await this.contractWrapper.read("getBaseURICount",[]);if(e.eq(0))throw Error("No base URI set. Please set a base URI before updating metadata");let n=i.O$.from(t),s=i.O$.from(0),c=i.O$.from(0),o=0;for(let t=0;t<e.toNumber()&&(o=t,!(c=await this.contractWrapper.read("getBatchIdAtIndex",[o])).gt(n));t++)s=c;let p=Array.from({length:c.sub(s).toNumber()},(t,a)=>a+s.toNumber()),l=await Promise.all(p.map(t=>this.erc721.getTokenMetadata(t))),d=[];for(let t=0;t<l.length;t++){let{id:r,uri:e,...s}=l[t];i.O$.from(n).eq(i.O$.from(r))?d.push(a):d.push(s)}let m=await (0,h.u)(d,this.storage,s.toNumber(),r),g=m[0].substring(0,m[0].lastIndexOf("/"));return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateBatchBaseURI",args:[o,`${g.endsWith("/")?g:`${g}/`}`]})});detectErc721Revealable(){if((0,d.d)(this.contractWrapper,"ERC721Revealable"))return new g.D(this.contractWrapper,this.storage,p.cP.name,()=>this.erc721.nextTokenIdToMint())}};let Erc721LoyaltyCard=class Erc721LoyaltyCard{featureName=p.cQ.name;constructor(t){this.contractWrapper=t}cancel=(0,u.f)(async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancel",args:[t]}));revoke=(0,u.f)(async t=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"revoke",args:[t]}))};let Erc721UpdatableMetadata=class Erc721UpdatableMetadata{featureName=p.cR.name;constructor(t,a){this.contractWrapper=t,this.storage=a}update=(0,u.f)(async(t,a)=>{let r=await (0,h.b)(a,this.storage);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,r]})})};let Erc721BatchMintable=class Erc721BatchMintable{featureName=p.cS.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r}to=(0,u.f)(async(t,a)=>{let[r,e]=await Promise.all([(0,h.u)(a,this.storage),(0,p.aL)(t)]),i=new y.C(this.contractWrapper),n=r.map(t=>i.encode("mintTo",[e,t]));return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:t=>{let r=this.contractWrapper.parseLogs("TokensMinted",t.logs);if(0===r.length||r.length<a.length)throw Error("TokenMinted event not found, minting failed");return r.map(a=>{let r=a.args.tokenIdMinted;return{id:r,receipt:t,data:()=>this.erc721.get(r)}})}})})};let Erc721Mintable=class Erc721Mintable{featureName=p.cT.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r,this.batch=this.detectErc721BatchMintable()}to=(0,u.f)(async(t,a)=>{let[r,e]=await Promise.all([(0,h.b)(a,this.storage),(0,p.aL)(t)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[e,r],parse:t=>{let a=this.contractWrapper.parseLogs("Transfer",t?.logs);if(0===a.length)throw Error("TransferEvent event not found");let r=a[0].args.tokenId;return{id:r,receipt:t,data:()=>this.erc721.get(r)}}})});async getMintTransaction(t,a){return this.to.prepare(await (0,p.aL)(t),a)}detectErc721BatchMintable(){if((0,d.d)(this.contractWrapper,"ERC721BatchMintable"))return new Erc721BatchMintable(this.erc721,this.contractWrapper,this.storage)}};let Erc721SharedMetadata=class Erc721SharedMetadata{featureName=p.cU.name;constructor(t,a){this.contractWrapper=t,this.storage=a}async get(){let t=await this.contractWrapper.read("sharedMetadata",[]);if(!t.every(t=>""===t))return{name:t.name,description:t.description,image:t.imageURI,animation_url:t.animationURI}}set=(0,u.f)(async t=>{let a=w.B.parse(t);a.description=this.sanitizeJSONString(a.description);let r=[];(0,W.XT)(a.image)?r.push(this.storage.upload(a.image)):"string"==typeof a.image?r.push(Promise.resolve(a.image)):r.push(Promise.resolve(void 0)),(0,W.XT)(a.animation_url)?r.push(this.storage.upload(a.animation_url)):"string"==typeof a.animation_url?r.push(Promise.resolve(a.animation_url)):r.push(Promise.resolve(void 0));let[e,i]=await Promise.all(r);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setSharedMetadata",args:[{name:`${a.name||""}`,description:a.description||"",imageURI:e||"",animationURI:i||""}]})});sanitizeJSONString(t){if(!t)return t;let a=JSON.stringify(t);return a.slice(1,a.length-1)}};let Erc721Enumerable=class Erc721Enumerable{featureName=p.cV.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}async all(t,a){let r=await this.tokenIds(t);if(a){let t=a?.start||0,e=a?.count||h.D;r=r.slice(t,t+e)}return await Promise.all(r.map(t=>this.erc721.get(t.toString())))}async tokenIds(t){let a=await (0,p.aL)(t||await this.contractWrapper.getSignerAddress()),r=await this.contractWrapper.read("balanceOf",[a]),e=Array.from(Array(r.toNumber()).keys());return await Promise.all(e.map(t=>this.contractWrapper.read("tokenOfOwnerByIndex",[a,t])))}};let Erc721AQueryable=class Erc721AQueryable{featureName=p.cW.name;constructor(t,a){this.erc721=t,this.contractWrapper=a}async all(t,a){let r=await this.tokenIds(t);if(a){let t=a?.start||0,e=a?.count||h.D;r=r.slice(t,t+e)}return await Promise.all(r.map(t=>this.erc721.get(t.toString())))}async tokenIds(t){let a=await (0,p.aL)(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("tokensOfOwner",[a])}};let Erc721Supply=class Erc721Supply{featureName=p.cX.name;constructor(t,a){this.erc721=t,this.contractWrapper=a,this.owned=this.detectErc721Owned()}async all(t){let a=i.O$.from(0);(0,d.h)("startTokenId",this.contractWrapper)&&(a=await this.contractWrapper.read("startTokenId",[]));let r=i.O$.from(t?.start||0).add(a).toNumber(),e=i.O$.from(t?.count||h.D).toNumber(),n=await this.erc721.nextTokenIdToMint(),s=Math.min(n.add(a).toNumber(),r+e);return await Promise.all([...Array(s-r).keys()].map(t=>this.erc721.get((r+t).toString())))}async allOwners(t){let a;let r=i.O$.from(0);(0,d.h)("startTokenId",this.contractWrapper)&&(r=await this.contractWrapper.read("startTokenId",[]));try{a=await this.erc721.totalClaimedSupply()}catch(t){a=await this.totalCount()}let e=[...Array((a=a.add(r)).toNumber()).keys()];if(t){let a=t?.start||0,r=t?.count||h.D;e=e.slice(a,a+r)}let n=await Promise.all(e.map(t=>this.erc721.ownerOf(t).catch(()=>s.d)));return e.map(t=>({tokenId:t,owner:n[t]})).filter(t=>t.owner!==s.d)}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.read("totalSupply",[])}detectErc721Owned(){return(0,d.d)(this.contractWrapper,"ERC721Enumerable")?new Erc721Enumerable(this.erc721,this.contractWrapper):(0,d.d)(this.contractWrapper,"ERC721AQueryable")?new Erc721AQueryable(this.erc721,this.contractWrapper):void 0}};let E=b.B.extend({tierPriority:C.z.array(C.z.string()),royaltyRecipient:p.b9.default(s.d),royaltyBps:p.cB.default(0),quantity:p.b5.default(1)}),S=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}];let Erc721TieredDrop=class Erc721TieredDrop{featureName=p.cY.name;constructor(t,a,r){this.erc721=t,this.contractWrapper=a,this.storage=r}async getMetadataInTier(t){let a=await this.contractWrapper.read("getMetadataForAllTiers",[]),r=a.find(a=>a.tier===t);if(!r)throw Error("Tier not found in contract.");let e=await Promise.all(r.ranges.map((t,a)=>{let e=[],i=r.baseURIs[a];for(let a=t.startIdInclusive.toNumber();a<t.endIdNonInclusive.toNumber();a++){let t=i.endsWith("/")?`${i}${a}`:`${i}/${a}`,r=this.storage.downloadJSON(t);e.push(r)}return e}).flat());return e}async getTokensInTier(t){let a=await this.contractWrapper.read("getTokensInTierLen",[]);if(a.eq(0))return[];let r=await this.contractWrapper.read("getTokensInTier",[t,0,a]),e=await Promise.all(r.map(t=>{let a=[];for(let r=t.startIdInclusive.toNumber();r<t.endIdNonInclusive.toNumber();r++)a.push(this.erc721.get(r));return a}).flat());return e}createBatchWithTier=(0,u.f)(async(t,a,r)=>{let e=await this.erc721.nextTokenIdToMint(),i=await (0,h.u)(t,this.storage,e.toNumber(),r),s=(0,h.g)(i);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[i.length,s.endsWith("/")?s:`${s}/`,a,n.Y0("")],parse:t=>{let a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args[1],e=a[0].args[2],i=[];for(let a=r;a.lte(e);a=a.add(1))i.push({id:a,receipt:t,data:()=>this.erc721.getTokenMetadata(a)});return i}})});createDelayedRevealBatchWithTier=(0,u.f)(async(t,a,r,e,i)=>{if(!r)throw Error("Password is required");let s=await this.storage.uploadBatch([w.C.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),p=(0,h.g)(s),l=await this.erc721.nextTokenIdToMint(),d=await this.storage.uploadBatch(a.map(t=>w.C.parse(t)),{onProgress:i?.onProgress,rewriteFileNames:{fileStartNumber:l.toNumber()}}),m=(0,h.g)(d),g=await this.contractWrapper.read("getBaseURICount",[]),y=await this.contractWrapper.getChainID(),W=c.keccak256(["string","uint256","uint256","address"],[r,y,g,this.contractWrapper.address]),f=await this.contractWrapper.read("encryptDecrypt",[n.Y0(m),W]),T=c.keccak256(["bytes","bytes","uint256"],[n.Y0(m),W,y]),C=o.$.encode(["bytes","bytes32"],[f,T]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[d.length,p.endsWith("/")?p:`${p}/`,e,C],parse:t=>{let a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),r=a[0].args[1],e=a[0].args[2],i=[];for(let a=r;a.lte(e);a=a.add(1))i.push({id:a,receipt:t,data:()=>this.erc721.getTokenMetadata(a)});return i}})});reveal=(0,u.f)(async(t,a)=>{if(!a)throw Error("Password is required");let r=await this.contractWrapper.getChainID(),e=c.keccak256(["string","uint256","uint256","address"],[a,r,t,this.contractWrapper.address]);try{let a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw Error("invalid password")}catch(t){throw Error("invalid password")}return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})});async generate(t){let[a]=await this.generateBatch([t]);return a}async generateBatch(t){let a=await Promise.all(t.map(t=>E.parseAsync(t))),r=await this.contractWrapper.getChainID(),e=this.contractWrapper.getSigner();return(0,f.Z)(e,"No signer available"),await Promise.all(a.map(async t=>{let a=await this.contractWrapper.signTypedData(e,{name:"SignatureAction",version:"1",chainId:r,verifyingContract:this.contractWrapper.address},{GenericRequest:S},await this.mapPayloadToContractStruct(t));return{payload:t,signature:a.toString()}}))}async verify(t){let a=await this.mapPayloadToContractStruct(t.payload),r=await this.contractWrapper.read("verify",[a,t.signature]);return r[0]}async claimWithSignature(t){let a=await this.mapPayloadToContractStruct(t.payload),r=await (0,T.n)(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),e=await this.contractWrapper.getCallOverrides();await (0,w.s)(this.contractWrapper,r,t.payload.currencyAddress,e);let i=await this.contractWrapper.sendTransaction("claimWithSignature",[a,t.signature],e),n=this.contractWrapper.parseLogs("TokensClaimed",i?.logs),s=n[0].args.startTokenId,c=s.add(n[0].args.quantityClaimed),o=[];for(let t=s;t.lt(c);t=t.add(1))o.push({id:t,receipt:i,data:()=>this.erc721.get(t)});return o}async mapPayloadToContractStruct(t){let a=await (0,T.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),r=o.$.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,a,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:r}}};let Erc721WithQuantitySignatureMintable=class Erc721WithQuantitySignatureMintable{featureName=p.cZ.name;constructor(t,a){this.contractWrapper=t,this.storage=a}mint=(0,u.f)(async t=>{let a=t.payload,r=t.signature,e=await this.contractWrapper.getCallOverrides(),parse=t=>{let a=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===a.length)throw Error("No MintWithSignature event found");let r=a[0].args.tokenIdMinted;return{id:r,receipt:t}};if(await this.isLegacyNFTContract()){let t=await this.mapLegacyPayloadToContractStruct(a),i=t.price;return await (0,w.s)(this.contractWrapper,i,a.currencyAddress,e),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:e,parse})}{let t=await this.mapPayloadToContractStruct(a),i=t.pricePerToken.mul(t.quantity);return await (0,w.s)(this.contractWrapper,i,a.currencyAddress,e),u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[t,r],overrides:e,parse})}});mintBatch=(0,u.f)(async t=>{let a=await this.isLegacyNFTContract(),r=(await Promise.all(t.map(t=>a?this.mapLegacyPayloadToContractStruct(t.payload):this.mapPayloadToContractStruct(t.payload)))).map((a,r)=>{let e=t[r],n=e.signature,s=e.payload.price;if(i.O$.from(s).gt(0))throw Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:a,signature:n}}),e=new y.C(this.contractWrapper),n=r.map(t=>e.encode("mintWithSignature",[t.message,t.signature]));if((0,d.h)("multicall",this.contractWrapper))return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:t=>{let a=this.contractWrapper.parseLogs("TokensMintedWithSignature",t.logs);if(0===a.length)throw Error("No MintWithSignature event found");return a.map(a=>({id:a.args.tokenIdMinted,receipt:t}))}});throw Error("Multicall not available on this contract!")});async verify(t){let a;let r=await this.isLegacyNFTContract(),e=t.payload,i=t.signature;return a=r?await this.mapLegacyPayloadToContractStruct(e):await this.mapPayloadToContractStruct(e),(await this.contractWrapper.read("verify",[a,i]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){let a=await this.isLegacyNFTContract(),r=await Promise.all(t.map(t=>b.t.parseAsync(t))),e=r.map(t=>t.metadata),i=await (0,h.u)(e,this.storage),n=await this.contractWrapper.getChainID(),s=this.contractWrapper.getSigner();return(0,f.Z)(s,"No signer available"),await Promise.all(r.map(async(t,r)=>{let e;let c=i[r],o=await b.u.parseAsync({...t,uri:c});return e=a?await this.contractWrapper.signTypedData(s,{name:"TokenERC721",version:"1",chainId:n,verifyingContract:this.contractWrapper.address},{MintRequest:b.v},await this.mapLegacyPayloadToContractStruct(o)):await this.contractWrapper.signTypedData(s,{name:"SignatureMintERC721",version:"1",chainId:n,verifyingContract:await this.contractWrapper.address},{MintRequest:b.x},await this.mapPayloadToContractStruct(o)),{payload:o,signature:e.toString()}}))}async mapPayloadToContractStruct(t){let a=await (0,T.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:a,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){let a=await (0,T.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:a,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return(0,d.d)(this.contractWrapper,"ERC721SignatureMintV1")}};let Erc721=class Erc721{featureName=p.c_.name;get chainId(){return this._chainId}constructor(t,a,r){this.contractWrapper=t,this.storage=a,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this.claimZora=this.detectErc721ClaimableZora(),this.erc721SharedMetadata=this.detectErc721SharedMetadata(),this.loyaltyCard=this.detectErc721LoyaltyCard(),this.updatableMetadata=this.detectErc721UpdatableMetadata(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){let[a,r]=await Promise.all([this.ownerOf(t).catch(()=>s.d),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...h.F}))]);return{owner:a,metadata:r,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.read("ownerOf",[t])}async balanceOf(t){return await this.contractWrapper.read("balanceOf",[await (0,p.aL)(t)])}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,a){let[r,e]=await Promise.all([(0,p.aL)(t),(0,p.aL)(a)]);return await this.contractWrapper.read("isApprovedForAll",[r,e])}transfer=(0,u.f)(async(t,a)=>{let[r,e]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,p.aL)(t)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[r,e,a]})});transferFrom=(0,u.f)(async(t,a,r)=>{let[e,i]=await Promise.all([(0,p.aL)(t),(0,p.aL)(a)]);return u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[e,i,r]})});setApprovalForAll=(0,u.f)(async(t,a)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await (0,p.aL)(t),a]}));setApprovalForToken=(0,u.f)(async(t,a)=>u.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await (0,p.aL)(t),a]}));async getAll(t){return(0,l.a)(this.query,p.cX).all(t)}async getAllOwners(t){return(0,l.a)(this.query,p.cX).allOwners(t)}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return(0,l.a)(this.query,p.cX).totalCirculatingSupply()}async getOwned(t,a){if(t&&(t=await (0,p.aL)(t)),this.query?.owned)return this.query.owned.all(t,a);{let[r,e]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners(a)]),i=(e||[]).filter(t=>r?.toLowerCase()===t.owner?.toLowerCase());return await Promise.all(i.map(async t=>this.get(t.tokenId)))}}async getOwnedTokenIds(t){if(t&&(t=await (0,p.aL)(t)),this.query?.owned)return this.query.owned.tokenIds(t);{let[a,r]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);return(r||[]).filter(t=>a?.toLowerCase()===t.owner?.toLowerCase()).map(t=>i.O$.from(t.tokenId))}}mint=(0,u.f)(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintTo=(0,u.f)(async(t,a)=>(0,l.a)(this.mintable,p.cT).to.prepare(t,a));async getMintTransaction(t,a){return this.mintTo.prepare(t,a)}mintBatch=(0,u.f)(async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintBatchTo=(0,u.f)(async(t,a)=>(0,l.a)(this.mintable?.batch,p.cS).to.prepare(t,a));burn=(0,u.f)(async t=>(0,l.a)(this.burnable,p.cK).token.prepare(t));cancel=(0,u.f)(async t=>(0,l.a)(this.loyaltyCard,p.cQ).cancel.prepare(t));revoke=(0,u.f)(async t=>(0,l.a)(this.loyaltyCard,p.cQ).revoke.prepare(t));lazyMint=(0,u.f)(async(t,a)=>(0,l.a)(this.lazyMintable,p.cO).lazyMint.prepare(t,a));updateMetadata=(0,u.f)(async(t,a)=>this.lazyMintable?this.lazyMintable.updateMetadata.prepare(t,a):(0,l.a)(this.updatableMetadata,p.cR).update.prepare(t,a));async update(t,a){return this.updateMetadata(t,a)}claim=(0,u.f)(async(t,a)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,a));claimTo=(0,u.f)(async(t,a,r)=>{let e=this.claimWithConditions,i=this.claimCustom,n=this.claimZora;if(e)return e.to.prepare(t,a,r);if(i)return i.to.prepare(t,a,r);if(n)return n.to.prepare(t,a,r);throw new p.x(p.cN)});async getClaimTransaction(t,a,r){let e=this.claimWithConditions,i=this.claimCustom;if(e)return e.conditions.getClaimTransaction(t,a,r);if(i)return i.getClaimTransaction(t,a,r);throw new p.x(p.cN)}async totalClaimedSupply(){let t=this.contractWrapper;if((0,d.h)("totalMinted",t))return this.contractWrapper.read("totalMinted",[]);if((0,d.h)("nextTokenIdToClaim",t))return this.contractWrapper.read("nextTokenIdToClaim",[]);throw Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){let[t,a]=await Promise.all([this.nextTokenIdToMint(),this.totalClaimedSupply()]);return t.sub(a)}get claimConditions(){return(0,l.a)(this.claimWithConditions,p.cL).conditions}get tieredDrop(){return(0,l.a)(this.tieredDropable,p.cY)}get signature(){return(0,l.a)(this.signatureMintable,p.cZ)}get revealer(){return(0,l.a)(this.lazyMintable?.revealer,p.cP)}get sharedMetadata(){return(0,l.a)(this.erc721SharedMetadata,p.cU)}async getTokenMetadata(t){let a=await this.contractWrapper.read("tokenURI",[t]);if(!a)throw new p.n;return(0,h.f)(t,a,this.storage)}async nextTokenIdToMint(){if((0,d.h)("nextTokenIdToMint",this.contractWrapper)){let t=await this.contractWrapper.read("nextTokenIdToMint",[]);return(0,d.h)("startTokenId",this.contractWrapper)&&(t=t.sub(await this.contractWrapper.read("startTokenId",[]))),t}if((0,d.h)("totalSupply",this.contractWrapper))return await this.contractWrapper.read("totalSupply",[]);throw Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}detectErc721Enumerable(){if((0,d.d)(this.contractWrapper,"ERC721Supply")||(0,d.h)("nextTokenIdToMint",this.contractWrapper))return new Erc721Supply(this,this.contractWrapper)}detectErc721Mintable(){if((0,d.d)(this.contractWrapper,"ERC721Mintable"))return new Erc721Mintable(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if((0,d.d)(this.contractWrapper,"ERC721Burnable"))return new Erc721Burnable(this.contractWrapper)}detectErc721LazyMintable(){if((0,d.d)(this.contractWrapper,"ERC721LazyMintable"))return new Erc721LazyMintable(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if((0,d.d)(this.contractWrapper,"ERC721TieredDrop"))return new Erc721TieredDrop(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if((0,d.d)(this.contractWrapper,"ERC721SignatureMintV1")||(0,d.d)(this.contractWrapper,"ERC721SignatureMintV2"))return new Erc721WithQuantitySignatureMintable(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if((0,d.d)(this.contractWrapper,"ERC721ClaimConditionsV1")||(0,d.d)(this.contractWrapper,"ERC721ClaimConditionsV2")||(0,d.d)(this.contractWrapper,"ERC721ClaimPhasesV1")||(0,d.d)(this.contractWrapper,"ERC721ClaimPhasesV2"))return new Erc721ClaimableWithConditions(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if((0,d.d)(this.contractWrapper,"ERC721ClaimCustom"))return new Erc721Claimable(this,this.contractWrapper)}detectErc721ClaimableZora(){if((0,d.d)(this.contractWrapper,"ERC721ClaimZora"))return new Erc721ClaimableZora(this,this.contractWrapper)}detectErc721SharedMetadata(){if((0,d.d)(this.contractWrapper,"ERC721SharedMetadata"))return new Erc721SharedMetadata(this.contractWrapper,this.storage)}detectErc721LoyaltyCard(){if((0,d.d)(this.contractWrapper,"ERC721LoyaltyCard"))return new Erc721LoyaltyCard(this.contractWrapper)}detectErc721UpdatableMetadata(){if((0,d.d)(this.contractWrapper,"ERC721UpdatableMetadata"))return new Erc721UpdatableMetadata(this.contractWrapper,this.storage)}}}}]);